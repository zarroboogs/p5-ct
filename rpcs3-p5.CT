<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="38">
  <Forms>
    <frmComp Class="TCEForm" Encoding="Ascii85">g[5yyn=MkTkHg^,Fs^/1$,(ctNs$*-VvRM%vc?2%OLCx/xDnhjcPB.4]^W%]q^]$K)*%Iu06}BdnG]Aa-])%[-]igpp:3UJLz3]jB4kNcvJ6F8T_{[b:38vt0$b/Wd@XHPROU{Kde4=RH+;:cgj_B0W]Zl%OIdtS8p=a%TPJ1rjI*w]0n{B,]cMF_Qx!A5F2D.523,?Sw}bF_Zz8yU9p,TVpo!/t.[1im*[.s_61PdUjrjMtiDt9{i%f-r-G){iG-o:=30YMWwudEhYj,V-]ia43tJw7h?#y65TjLLpI)r]sC)I$,q,$/hOhQp=ORg;r64FXD!7VZesRXBOJ;H^p3Qym4;Z@fz5l^u4em(4FUuLxDd;UlTgs%Gr/itYib]Ff{V}]vwAePdB)7Bz@@x=Q?jK*Wk-M*9}5vsZrp;e%_V5[y?PO5n%vW.I9fA0XlY]+x1)LH,CPhv,8.oX%VMdxRXA:0an3tkMNi}mBM#q3^feT_njb{q$Qf;HsMc9q7O;aA*o?,(%lU$h6:fz9veOfeBce+g</frmComp>
    <frmExpCalc Class="TCEForm" Encoding="Ascii85">ZIVrn):Zr?U7ObVsRqFYi3J-rAR*wdmeVv/E47[y5(:7KlCO/b$F3YR)^h4Y%po]kS7OHj$Zuy[x^G7yeV@xx9_%HGF!?9y(z}rrJ1d=0yRFAWLL#:ty:QY,8S/VCroh+k!QV-ww(YK+_AnU{BfpV5QaS{aOO!0!Va(sQVIW[C^NcoW!6nc6Pv{mCW-owRaS=L47BKV#2Wh%!w@==^!-/mSqn9xqf{z8!WjOohO_Nc3KXU7;[Pf7!y.]yy26UzhxZN/Peid,(WR$M96TX8KRg!,nO(=PKYfziv51rVnN)^ekz3!2911!CkVsBd!i=1tsjI0nuXqYw[,2!LL/l1Byy?,6Erd+n.*l**gN*s@;EZH1wHTr^9F.XH$$SQf{ECw,Uu^aPp9ntfe:v[mEUs8^44OenN%A./.G[,k7LT.JlsXSIAwX;5rVtNgxIBPgQ7(@1@M_EBOhV3FL##)L1;Q2siVII_cPjH/Q[o)6odGbGUdAH6WN4lKQh-qr#IoyIc0e*Sl)Kbzz1;50-ly=gEtUwjKipGf??nq9Z**Y%6.i72?Gj(%?-g;maPb{QhqHg]nnqu,]9eX%!@YGw-FE39t4sli(+GO3Bquv}%]t^,HH1rP</frmExpCalc>
    <frmNames Class="TCEForm" Encoding="Ascii85">wUoh+):ZT+U8k,nBobN*X*hd+kT=KBoH=-#(32]Bx7tK-L^2hkEgU.=yrSjAiy)35@;[f^BrTgjxlnF#X6B#y^.}Xggiy2!UXjS31ybd9rt*i:LpfYPrme4dJO^SkXlppIB3W49)da!)@}QQLaHmqGpso?rO4o}7xGOc{OAvQX%$7^BoP7q:W]%mkf!J^wGO[01]J92!2W[]G?1=y!3jNaGP!*nE-o/rz@{)NC,:jErtwT+A^xPXfX5jH8mqL}WO}9#tu9!_Xgk)j*wvZwNI7@v!Aq_*,wW,BYanK@-b3:%qwt)MIX9[(+cK%ZnXGK+-VIsC2)fG!Y/AEIl4;eU9qe:C-0I{8@jLst1;N#ujeaWRFB.iv_laHNHW8F9[r.=]#+%iow#:t!u@B(5;J/5X]/ynJ+pAerGnn@Jp*dg-dXWi4jr_4FS3.Gv9uN8cB5FDEPp5ESS2hy%u(uMaMr[q0O]clce..1q6-/[?tjyO_Y!k%8wnzyI62A_d%1G0o%k}{w}HLnGB[K)FER8wqQiWh?[qqqf^-Uz.%^Nk}W?Z8(*Q+F)3T,+UDUc0lb-PxzZ(d%OZ(eF%Gh$b3T]MS41@b-</frmNames>
  </Forms>
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"[ENABLE] P5 @ RPCS3"</Description>
      <Color>0000FF</Color>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local base = 0x400000000

updateSymbol("_segHero",        base + 0x010AF270, true)
updateSymbol("_segInParty",     base + 0x010B0CB0, true)
updateSymbol("_segInventory",   base + 0x010B0CC2, true)
updateSymbol("_segYen",         base + 0x010B21C4, true)
updateSymbol("_segFlags",       base + 0x010B21C8, true)
updateSymbol("_segGlobals",     base + 0x010B2628, true)
updateSymbol("_segCompendium",  base + 0x010B2A28, true)
updateSymbol("_segEnemyData",   base + 0x010B8128, true)
updateSymbol("_segTime",        base + 0x010B8700, true)
updateSymbol("_segItemInfo",    base + 0x010B8708, true)
updateSymbol("_segConfidants",  base + 0x010C1708, true)
updateSymbol("_segSocialStats", base + 0x010C1870, true)
updateSymbol("_segNames",       base + 0x010C187A, true)
updateSymbol("_segPlayTime",    base + 0x010C384C, true)
updateSymbol("_segActivityLog", base + 0x010C3850, true)
updateSymbol("_segTrophies",    base + 0x010C3B1C, true)
updateSymbol("_segFieldData",   base + 0x010DDB80, true)

PARTY_MEM_SIZE = 0x2A0
PARTY_MEM_COUNT = 9
CONF_COUNT = 22
ACT_PROG_TYPE = vtCustom
STOCK_MAX = 12
PERSONA_SIZE = 0x30
CONF_SIZE = 0x10

DATA = {
  ["acc"]      = "data/acc.tsv",
  ["activity"] = "data/activity.tsv",
  ["ail"]      = "data/ailment.tsv",
  ["arcana"]   = "data/arcana.tsv",
  ["buff"]     = "data/buff.tsv",
  ["card"]     = "data/card.tsv",
  ["commu"]    = "data/commu.tsv",
  ["enemy"]    = "data/enemy.tsv",
  ["flag"]     = "data/flag.tsv",
  ["futaba"]   = "data/futaba.tsv",
  ["global"]   = "data/global.tsv",
  ["key"]      = "data/key.tsv",
  ["melee"]    = "data/melee.tsv",
  ["misc"]     = "data/misc.tsv",
  ["morgana"]  = "data/morgana.tsv",
  ["outfit"]   = "data/outfit.tsv",
  ["party"]    = "data/party.tsv",
  ["persona"]  = "data/persona.tsv",
  ["prot"]     = "data/prot.tsv",
  ["ranged"]   = "data/ranged.tsv",
  ["skill"]    = "data/skill.tsv",
  ["treasure"] = "data/treasure.tsv",
}
tab = loadData(DATA)

INVENTORY = {
  { cat = 0, name = "Melee Weapons",  size = 1024, data = tab.melee    },
  { cat = 1, name = "Protector",      size = 1024, data = tab.prot     },
  { cat = 2, name = "Accessory",      size = 0512, data = tab.acc      },
  { cat = 3, name = "Cons. &amp; Essen.", size = 0512, data = tab.misc     },
  { cat = 4, name = "Key &amp; Palace",   size = 0256, data = tab.key      },
  { cat = 5, name = "Treasure",       size = 1024, data = tab.treasure },
  { cat = 6, name = "Skill Cards",    size = 0512, data = tab.card     },
  { cat = 7, name = "Outfit",         size = 0256, data = tab.outfit   },
  { cat = 8, name = "Ranged Weapons", size = 0256, data = tab.ranged   },
}
tab.items = createItemTable(INVENTORY)
tab.date = createDateTable()

LIST = {
  { name = "dlSkill",   data = tab.skill   },
  { name = "dlPersona", data = tab.persona },
  { name = "dlEnemy",   data = tab.enemy   },
  { name = "dlCmm",     data = tab.commu   },
  { name = "dlDate",    data = tab.date    },
  { name = "dlParty",   data = tab.party   },
  { name = "dlItem",    data = tab.items   },
}
createDynamicLists(LIST)

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end

{$asm}

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>1</ID>
      <Description>"Internal Stuff"</Description>
      <Options moHideChildren="1" moManualExpandCollapse="1" />
      <Color>C0C0C0</Color>
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>2</ID>
          <Description>"Dynamic Lists"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
        </CheatEntry>
        <CheatEntry>
          <ID>3</ID>
          <Description>"Static Lists"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>4</ID>
              <Description>"slBuffDirection"</Description>
              <DropDownList DescriptionOnly="1" DisplayValueAsItem="1">0:None
1:Up
14:Down
</DropDownList>
              <VariableType>4 Bytes</VariableType>
              <Address />
            </CheatEntry>
            <CheatEntry>
              <ID>5</ID>
              <Description>"slTime"</Description>
              <DropDownList DisplayValueAsItem="1">0:Early Morning
1:Morning
2:Lunchtime
3:Afternoon
4:After School/Daytime
5:Evening
6:Late Night
</DropDownList>
              <VariableType>Byte</VariableType>
              <Address />
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>6</ID>
          <Description>"Struct Records"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>7</ID>
              <Description>"dsCmm"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>8</ID>
                  <Description>"Flag"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>0</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>9</ID>
                  <Description>"Id"</Description>
                  <DropDownListLink>dlCmm</DropDownListLink>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>2</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>10</ID>
                  <Description>"Rank"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>4</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>11</ID>
                  <Description>"Affinity"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>6</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>12</ID>
              <Description>"dsPersona"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>13</ID>
                  <Description>"Flags"</Description>
                  <ShowAsHex>1</ShowAsHex>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>0</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>14</ID>
                  <Description>"Id"</Description>
                  <DropDownListLink>dlPersona</DropDownListLink>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>2</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>15</ID>
                  <Description>"Level"</Description>
                  <VariableType>Byte</VariableType>
                  <Address>4</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>16</ID>
                  <Description>"EXP"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>4 Byte Big Endian</CustomType>
                  <Address>8</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>17</ID>
                  <Description>"Skills"</Description>
                  <Options moHideChildren="1" moManualExpandCollapse="1" />
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = 0xC + memrec.Parent[0].CurrentAddress

for i = 0, 7 do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Address = from + i * 2
  rec.Type = vtCustom
  rec.CustomTypeName = "2 Byte Big Endian"
  rec.Description = string.format("Skill #%d", i + 1)

  rec.DropDownLinked = true
  rec.DropDownLinkedMemrec = "dlSkill"
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>18</ID>
                  <Description>"Stats"</Description>
                  <Options moHideChildren="1" moManualExpandCollapse="1" />
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = 0x1C + memrec.Parent[0].CurrentAddress
local statGroup = { "Stats", "Stats Ex", "Stats Ex Temp" }
local statName = { "St", "Ma", "En", "Ag", "Lu" }

for i = 0, 2 do
  for j = 0, 4 do
    local rec = mrNew()
    rec.appendToEntry(memrec)
    rec.DontSave = true

    rec.Address = from + i * 5 + j
    rec.Type = vtByte

    rec.Description = string.format("%s - %s", statGroup[i + 1], statName[j + 1])
  end
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>19</ID>
              <Description>"dsUnit"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>20</ID>
                  <Description>"Flags"</Description>
                  <ShowAsHex>1</ShowAsHex>
                  <VariableType>Custom</VariableType>
                  <CustomType>4 Byte Big Endian</CustomType>
                  <Address>0</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>21</ID>
                  <Description>"Type"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>4</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>22</ID>
                  <Description>"Id"</Description>
                  <DropDownListLink>dlParty</DropDownListLink>
                  <VariableType>Custom</VariableType>
                  <CustomType>4 Byte Big Endian</CustomType>
                  <Address>8</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>23</ID>
                  <Description>"HP"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>4 Byte Big Endian</CustomType>
                  <Address>C</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>24</ID>
                  <Description>"SP"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>4 Byte Big Endian</CustomType>
                  <Address>10</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>25</ID>
                  <Description>"Ailments"</Description>
                  <Options moHideChildren="1" moManualExpandCollapse="1" />
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = 0x14 + memrec.Parent[0].CurrentAddress

for _, v in pairs(tab.ail) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Type = vtBinary
  rec.Address = from + 3 - v.id // 8
  rec.Binary.Startbit = v.id % 8
  rec.Binary.Size = 1
  rec.Description = v.name
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>26</ID>
                  <Description>"[Enemy] Level"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>18</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>27</ID>
                  <Description>"[Hero] Level"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>18</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>28</ID>
                  <Description>"[Hero] EXP"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>4 Byte Big Endian</CustomType>
                  <Address>1C</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>29</ID>
                  <Description>"Buff Status"</Description>
                  <Options moHideChildren="1" moManualExpandCollapse="1" />
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = 0x24 + memrec.Parent[0].CurrentAddress

for _, v in pairs(tab.buff) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Type = vtBinary
  rec.Address = from + 3 - v.id // 8
  rec.Binary.Startbit = v.id % 8
  rec.Binary.Size = 1
  rec.Description = v.name
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>30</ID>
                  <Description>"Buff Direction"</Description>
                  <Options moHideChildren="1" moManualExpandCollapse="1" />
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = 0x2C + memrec.Parent[0].CurrentAddress

for _, v in pairs(tab.buff) do
  if 1 * v.id &gt; 19 then return end

  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Type = vtBinary
  rec.Address = from + v.id // 2
  rec.Binary.Startbit = (v.id % 2) * 4
  rec.Binary.Size = 4
  rec.Description = v.name

  addDDLRef(rec, false, "slBuffDirection", nil)
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>31</ID>
                  <Description>"Buff Duration"</Description>
                  <Options moHideChildren="1" moManualExpandCollapse="1" />
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = 0x36 + memrec.Parent[0].CurrentAddress

for _, v in pairs(tab.buff) do
  if 1 * v.id &gt; 19 then return end

  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Type = vtBinary
  rec.Address = from + v.id // 2
  rec.Binary.Startbit = (v.id % 2) * 4
  rec.Binary.Size = 4
  rec.Description = v.name
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>32</ID>
                  <Description>"[Hero] Marked Persona (In Menu)"</Description>
                  <VariableType>Byte</VariableType>
                  <Address>41</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>33</ID>
                  <Description>"Equip"</Description>
                  <Options moHideChildren="1" moManualExpandCollapse="1" />
                  <VariableType>Auto Assembler Script</VariableType>
                  <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = 0x284 + memrec.Parent[0].CurrentAddress
local equipNames = { "Melee", "Protector", "Accessory", "Outfit", "Ranged" }

for i, v in pairs(equipNames) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Type = vtCustom
  rec.CustomTypeName = "2 Byte Big Endian"
  rec.Address = from + (i - 1) * 2
  rec.Description = v

  rec.DropDownLinked = true
  rec.DropDownLinkedMemrec = "dlItem"
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
                </CheatEntry>
                <CheatEntry>
                  <ID>34</ID>
                  <Description>"Bullets"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>294</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>35</ID>
                  <Description>"HP Gain"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>29C</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>36</ID>
                  <Description>"SP Gain"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>29E</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
            <CheatEntry>
              <ID>37</ID>
              <Description>"dsFieldData"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <GroupHeader>1</GroupHeader>
              <CheatEntries>
                <CheatEntry>
                  <ID>38</ID>
                  <Description>"Field Major Id"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>0</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>39</ID>
                  <Description>"Field Minor Id"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>2</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>40</ID>
                  <Description>"???"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>4</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>41</ID>
                  <Description>"???"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>2 Byte Big Endian</CustomType>
                  <Address>6</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>42</ID>
                  <Description>"Player X"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>8</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>43</ID>
                  <Description>"Player Y"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>C</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>44</ID>
                  <Description>"Player Z"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>10</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>45</ID>
                  <Description>"???"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>14</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>46</ID>
                  <Description>"???"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>18</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>47</ID>
                  <Description>"???"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>1C</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>48</ID>
                  <Description>"Player Rot"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>20</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>49</ID>
                  <Description>"Camera Rot"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>24</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>50</ID>
                  <Description>"???"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>28</Address>
                </CheatEntry>
                <CheatEntry>
                  <ID>51</ID>
                  <Description>"???"</Description>
                  <VariableType>Custom</VariableType>
                  <CustomType>Float Big Endian</CustomType>
                  <Address>2C</Address>
                </CheatEntry>
              </CheatEntries>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>52</ID>
      <Description>"Tools"</Description>
      <Options moHideChildren="1" moManualExpandCollapse="1" />
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>53</ID>
          <Description>"Experience Calculator"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local form = frmExpCalc

if not frmExpCalcReset then form.Show() return end
frmExpCalcReset = false

local base_level, level = 121, 99

local function calcExp()
  local coeff = base_level and -0.019 * base_level + 3.7 or 1.4
  local exp = math.floor(coeff * level ^ 3 + 10) * (1 - math.floor(1 / level))

  form.edEXP.Text = exp
end

local function tbLevelChange(sender)
  level = tonumber(sender.Position)
  form.lblLevelVal.Caption = level

  calcExp()
end

local function cbTargetsSelect(sender)
  local index = sender.ItemIndex
  local id = string.match(sender.Items[index], "%d+")
  local persona = filterTable(tab.persona, fById(id))[1]
  base_level = tonumber(persona.lv)

  if not (fHasTag("Hero|DLC", false))(persona) then
     base_level = 121
  end

  calcExp()
end

local function init()
  form.cbTargets.Items.Clear()
  form.cbTargets.Items.Add("0 : PARTY MEMBER")

  for _, v in pairs(filterTable(tab.persona, fNotHasTag("FLR|BLN|INV|DUP", false))) do
    form.cbTargets.Items.Add(string.format("%d : %s", v.id, v.name))
  end
  form.cbTargets.ItemIndex = 0
  form.cbTargets.OnSelect = cbTargetsSelect

  form.lblLevelVal.Caption = level
  form.tbLevel.OnChange = tbLevelChange

  form.edEXP.Text = 0

  calcExp()
end

init()
form.Show()

{$asm}

[DISABLE]
{$lua}

frmExpCalc.Hide()

{$asm}

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>54</ID>
          <Description>"Name Changer"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local form = frmNames

if not frmNamesReset then form.Show() return end
frmNamesReset = false

local cm, cmr = {}, {}
local em, emr = {}, {}

-- init character maps
for _, v in pairs({{0x30, 0x39}, {0x41, 0x5A}, {0x61, 0x7A}}) do
  for j = v[1], v[2] do
    cm[j + 0x8060], cmr[utf8.char(j)] = utf8.char(j), j + 0x8060

    local o = j &lt; 0x60 and 0xEFBC60 or 0xEFBD20
    em[j + o], emr[utf8.char(j)] = utf8.char(j), j + o
  end
end

-- add special chars
local cm_special = {
  [0x8081] = 0x21,   [0x8083] = 0x23,   [0x8084] = 0x24,   [0x8085] = 0x25,
  [0x8086] = 0x26,   [0x8088] = 0x28,   [0x8089] = 0x29,   [0x808A] = 0x2A,
  [0x808B] = 0x2B,   [0x808F] = 0x2F,   [0x809A] = 0x3A,   [0x809D] = 0x3D,
  [0x809F] = 0x3F,   [0x80A0] = 0x40,   [0x828A] = 0x22C5, [0x8297] = 0x20,
  [0x8299] = 0x2212, [0x82AE] = 0xD7,   [0x82B0] = 0xF7,   [0x82B6] = 0x2642,
  [0x82B7] = 0x2640, [0x82C0] = 0x2606, [0x82C1] = 0x2605, [0x82C2] = 0x26AA,
  [0x82C3] = 0x26AB, [0x82C4] = 0x25CE, [0x9CA3] = 0x266A, [0x0000] = nil
}

local em_special = {
  [0xEFBC8B] = 0x2B,   [0xE383BC] = 0x2212, [0xC3B7] = 0xF7,     [0xC397] = 0xD7,
  [0xEFBC9D] = 0x3D,   [0xEFBC85] = 0x25,   [0xE383BB] = 0x22C5, [0xEFBC9A] = 0x3A,
  [0xEFBC8F] = 0x2F,   [0xEFBC9F] = 0x3F,   [0xEFBC81] = 0x21,   [0xEFBC88] = 0x28,
  [0xEFBC89] = 0x29,   [0xEFBCA0] = 0x40,   [0xEFBC86] = 0x26,   [0xE299AA] = 0x266A,
  [0xE29885] = 0x2605, [0xE29886] = 0x2606, [0xEFBC84] = 0x24,   [0xE2978B] = 0x26AA,
  [0xE2978F] = 0x26AB, [0xE2978E] = 0x25CE, [0xE29982] = 0x2642, [0xE29980] = 0x2640,
  [0xEFBC83] = 0x23,   [0xEFBC8A] = 0x2A,   [0xE38086] = 0x20,   [0x000000] = nil
}

for k, v in pairs(cm_special) do
  cm[k], cmr[utf8.char(v)] = utf8.char(v), k
end

for k, v in pairs(em_special) do
  em[k], emr[utf8.char(v)] = utf8.char(v), k
end

local function getName(addr, len)
  local name = {}
  for i = 0, len - 1 do
    table.insert(name, cm[readBE2(addr + i * 2)])
  end
  return table.concat(name)
end

local function toByte(n)
  local t = {}
  local x = math.max(1, math.ceil(select(2, math.frexp(n)) / 8))
  for i = 0, x - 1 do
    t[x - i] = (n &gt;&gt; (i * 8)) &amp; 0xFF
  end
  return t
end

local function setName(addr, len, map, ...)
  local count = 0

  -- write string to memory
  for nn, n in pairs{...} do
    if nn &gt; 1 then
      writeBytes(addr + count, 0x20)
      count = count + 1
      if count &gt;= len then break end
    end
    for i, v in utf8.codes(n) do
      local k = toByte(map[utf8.char(v)])
      writeBytes(addr + count, k)
      count = count + #k
      if count &gt;= len then break end
    end
  end

  -- zero out remaining length
  local pad = {}
  for i = 1, len - count do pad[i] = 0 end
  writeBytes(addr + count, pad)
end

local function validateName(name, max_len)
  local valid = ""
  if not name then return valid end
  for i, c in utf8.codes(name) do
    if cmr[utf8.char(c)] ~= nil then
      valid = valid .. utf8.char(c)
    end
    if i &gt;= max_len then break end
  end
  return valid
end

local function edLastNameChange(sender)
  sender.Text = validateName(sender.Text, 8)

  setName(0x4010C18B2, 8 * 2, cmr, sender.Text)
  setName(0x4010C18DA, 8 * 2 * 2 + 1, cmr, form.edFirstName.Text, sender.Text)
  setName(0x4010C187A, 8 * 3 * 2 + 1, emr, form.edFirstName.Text, sender.Text)
end

local function edFirstNameChange(sender)
  sender.Text = validateName(sender.Text, 8)

  setName(0x4010C18C6, 8 * 2, cmr, sender.Text)
  setName(0x4010C18DA, 8 * 2 * 2 + 1, cmr, sender.Text, form.edLastName.Text)
  setName(0x4010C187A, 8 * 3 * 2 + 1, emr, sender.Text, form.edLastName.Text)
end

local function edGroupNameChange(sender)
  sender.Text = validateName(sender.Text, 12)

  setName(0x4010C1902, 12 * 2, cmr, sender.Text)
  setName(0x4010C191B, 12 * 3, emr, sender.Text)
end

local function init()
  form.edLastName.OnChange = edLastNameChange
  form.edFirstName.OnChange = edFirstNameChange
  form.edGroupName.OnChange = edGroupNameChange

  local chars = ""
  for _, v in spairs(cm) do chars = chars .. "" .. v .. " " end
  form.mmChars.ReadOnly = true
  form.mmChars.Clear()
  form.mmChars.Append(chars)
end

local function frmNamesShow(sender)
  sender.edLastName.Text = getName(0x4010C18B2, 8)
  sender.edFirstName.Text = getName(0x4010C18C6, 8)
  sender.edGroupName.Text = getName(0x4010C1902, 12)
end

init()
form.OnShow = frmNamesShow
form.Show()

{$asm}

[DISABLE]
{$lua}

frmNames.Hide()

{$asm}

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>55</ID>
          <Description>"Compendium Unlocker"</Description>
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local form = frmComp

if not frmCompReset then form.Show() return end
frmCompReset = false

local COMP_BASE = getAddress("_segCompendium")

local function isUnlocked(id)
  return readBytes(COMP_BASE + id * PERSONA_SIZE + 0x01, 1) or 0
end

local function writeComp(flags, id, level, exp, skills, stats)
  local offset = COMP_BASE + id * PERSONA_SIZE

  writeBE2(offset + 0x00, flags)
  writeBE2(offset + 0x02, tonumber(level) &gt; 0 and id or 0)
  writeBytes(offset + 0x04, level)
  writeBE4(offset + 0x08, exp)

  for i, s in pairs(skills) do
    writeBE2(offset + 0x0C + (i - 1) * 0x02, s)
  end

  writeBytes(offset + 0x1C, stats)
end

local function lock(id)
  local flags, level, exp = 0, 0, 0
  local stats = { 0, 0, 0, 0, 0 }
  local skills = { 0, 0, 0, 0, 0, 0, 0, 0 }

  writeComp(flags, id, level, exp, skills, stats)
end

local function unlock(id)
  local p = filterTable(tab.persona, fById(id))[1]
  local flags, id, level, exp = 1, p.id, p.lv, p.exp
  local skills = { p.s1, p.s2, p.s3, p.s4, p.s5, p.s6, p.s7, p.s8 }
  local stats = { p.st, p.ma, p.en, p.ag, p.lu }

  writeComp(flags, id, level, exp, skills, stats)
end

local function lvCompItemChecked(sender, li)
  if li.Checked then
    unlock(li.SubItems[0])
  else
    lock(li.SubItems[0])
  end
end

local function frmCompShow(sender)
  for i = 0, sender.lvComp.Items.Count - 1 do
    local entry = sender.lvComp.Items.Item[i]
    entry.Checked = isUnlocked(entry.SubItems[0])
  end
end

local function btnLockAllClick(sender)
  for i = 0, form.lvComp.Items.Count - 1 do
    local item = form.lvComp.Items[i]
    lock(item.SubItems[0])
    item.Checked = false
    form.pbStatus.Position = i + 1
  end
end

local function btnUnlockAllClick(sender)
  for i = 0, form.lvComp.Items.Count - 1 do
    local item = form.lvComp.Items[i]
    if isUnlocked(item.SubItems[0]) == 0 then
      unlock(item.SubItems[0])
      item.Checked = true
    end
    form.pbStatus.Position = i + 1
  end
end

local function init()
  form.lvComp.Items.Clear()
  form.lvComp.Columns.Clear()

  -- columns
  for _, col in pairs({"Persona", "ID", "Base", "Arcana", "Tag"}) do
    local c = form.lvComp.Columns.Add()
    c.Caption = col
    c.AutoSize = true
  end

  local a2d = {}

  -- rows
  for _, p in spairs(filterTable(tab.persona, fHasTag("Hero|DLC")), oByArcanaLevel) do
    local entry = form.lvComp.Items.Add()
    entry.Caption = p.name

    entry.Checked = isUnlocked(p.id)

    local a = a2d[p.ar] or filterTable(tab.arcana, fById(p.ar))[1].name
    a2d[p.ar] = a

    entry.SubItems.Add(p.id)
    entry.SubItems.Add(p.lv)
    entry.SubItems.Add(a)
    entry.SubItems.Add(p.tag)
  end

  form.lvComp.OnItemChecked = lvCompItemChecked
  form.btnUnlockAll.OnClick = btnUnlockAllClick
  form.btnLockAll.OnClick = btnLockAllClick
  form.pbStatus.Position = 0
  form.pbStatus.Maximum = form.lvComp.Items.Count
end

init()
form.OnShow = frmCompShow
form.Show()

{$asm}

[DISABLE]
{$lua}

frmComp.Hide()

{$asm}

</AssemblerScript>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>56</ID>
      <Description>"Game Data"</Description>
      <Options moHideChildren="1" moManualExpandCollapse="1" />
      <GroupHeader>1</GroupHeader>
      <CheatEntries>
        <CheatEntry>
          <ID>57</ID>
          <Description>"Party Data"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>58</ID>
              <Description>"Hero Level"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segHero+18</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>59</ID>
              <Description>"Hero EXP"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>4 Byte Big Endian</CustomType>
              <Address>_segHero+1C</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>60</ID>
              <Description>"Party Stats"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segHero")
local tmp = mrClone(mrDesc("dsUnit"), from)
local party = filterTable(tab.party, fNotHasTag("BLN|FLR"))

for _, v in pairs(party) do
  local rec = mrClone(tmp, PARTY_MEM_SIZE * (v.id - 1))
  rec.appendToEntry(memrec)
  rec.DontSave = true

  for _, x in pairs(mrGetChildren(rec, mrByDesc("%[Hero%]"))) do x.destroy() end
  for _, x in pairs(mrGetChildren(rec, mrByDesc("%[Enemy%]"))) do x.destroy() end

  rec.Description = v.name
end

tmp.destroy()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>61</ID>
              <Description>"Hero Persona"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segHero+44")
local tmp = mrClone(mrDesc("dsPersona"), from)

for i = 0, STOCK_MAX - 1 do
  local rec = mrClone(tmp, PERSONA_SIZE * i)
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Description = string.format("Persona #%02d", i + 1)
end

tmp.destroy()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>62</ID>
              <Description>"Party Persona"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segHero+44")
local tmp = mrClone(mrDesc("dsPersona"), from)
local party = filterTable(tab.party, fNotHasTag("BLN|FLR"))

for _, v in pairs(party) do
  if v.id &gt; "1" then
    local rec = mrClone(tmp, PARTY_MEM_SIZE * (v.id - 1))
    rec.appendToEntry(memrec)
    rec.DontSave = true

    rec.Description = v.name
  end
end

tmp.destroy()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>63</ID>
          <Description>"Party Formation"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segInParty")

for i = 0, PARTY_MEM_COUNT - 1 do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Address = from + 2 * i
  rec.Type = vtCustom
  rec.CustomTypeName = "2 Byte Big Endian"
  rec.Description = string.format("Member #%02d", i + 1)

  addDDLRef(rec, false, "dlParty", nil)
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}


</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>64</ID>
          <Description>"Inventory"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segInventory")

for _, invGroup in pairs(INVENTORY) do
  local recGroup = mrNew()
  recGroup.appendToEntry(memrec)
  recGroup.DontSave = true

  recGroup.IsGroupHeader = true
  recGroup.Options = "[moHideChildren,moManualExpandCollapse]"
  recGroup.Description = invGroup.name

  local items = filterTable(invGroup.data, fNotHasTag("FLR|BLN", false))

  for _, invItem in pairs(items) do
    local rec = mrNew()
    rec.appendToEntry(recGroup)
    rec.DontSave = true

    rec.Type = vtByte
    rec.Address = from + invItem.id

    local desc = string.format("%03d. %s", invItem.id, invItem.name)
    if invItem.tag and invItem.tag ~= "" then
      desc = string.format("%s [%s]", desc, invItem.tag)
    end
    if invItem.skill and invItem.skill ~= "" and invItem.skill ~= "0" then
      desc = string.format("%s &lt;%s&gt;", desc, tab.skill[1 * invItem.skill + 1].name)
    end
    rec.Description = desc
  end

  from = from + invGroup.size
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>65</ID>
          <Description>"Money"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>66</ID>
              <Description>"Yen"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>4 Byte Big Endian</CustomType>
              <Address>_segYen+0</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>67</ID>
          <Description>"Flags"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segFlags")

for _, v in pairs(tab.flag) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Type = vtBinary
  rec.Address = from + 3 - v.id // 8 + (v.id // 32) * 8
  rec.Binary.Startbit = v.id % 8
  rec.Binary.Size = 1
  rec.Description = string.format("%04d. %s", v.id, v.name)
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>68</ID>
          <Description>"Counters"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segGlobals")

for _, v in pairs(tab.global) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Address = from + 4 * v.id
  rec.Type = vtCustom
  rec.CustomTypeName = "4 Byte Big Endian"
  rec.Description = string.format("%03d. %s", v.id, v.name)
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>69</ID>
          <Description>"Compendium"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>70</ID>
              <Description>"By ID"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segCompendium")
local tmp = mrClone(mrDesc("dsPersona"), from)
local comp = filterTable(tab.persona, fHasTag("Hero"))

for _, v in pairs(comp) do
  local rec = mrClone(tmp, PERSONA_SIZE * v.id)
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Description = string.format("%03d. %s &lt;%s&gt;", v.id, v.name, tab.arcana[1 * v.ar + 1].name)
end

tmp.destroy()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>71</ID>
              <Description>"By Base Level"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segCompendium")
local tmp = mrClone(mrDesc("dsPersona"), from)
local comp = filterTable(tab.persona, fHasTag("Hero"))

for _, v in spairs(comp, oByLevel) do
  local rec = mrClone(tmp, PERSONA_SIZE * v.id)
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Description = string.format("%03d. %s &lt;%s&gt;", v.id, v.name, tab.arcana[1 * v.ar + 1].name)
end

tmp.destroy()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>72</ID>
              <Description>"By Arcana"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segCompendium")
local tmp = mrClone(mrDesc("dsPersona"), from)
local comp = filterTable(tab.persona, fHasTag("Hero"))

for _, v in spairs(comp, oByArcanaLevel) do
  local rec = mrClone(tmp, PERSONA_SIZE * v.id, false)
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Description = string.format("%s | %03d. %s", tab.arcana[1 * v.ar + 1].name, v.id, v.name)
end

tmp.destroy()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>73</ID>
          <Description>"Enemy Data"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>74</ID>
              <Description>"Enemy Data - Known Aff."</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segEnemyData")
local affinities = { "Phys", "Gun", "Fire", "Ice", "Elec", "Wind", "Psy",
  "Nuke", "Bless", "Curse", "Almighty" }

local enemies = filterTable(tab.enemy, fNotHasTag("FLR|BLN", false))

for _, v in pairs(enemies) do
  local recEnemy = mrNew()
  recEnemy.appendToEntry(memrec)
  recEnemy.DontSave = true

  recEnemy.IsGroupHeader = true
  recEnemy.Options = "[moHideChildren, moManualExpandCollapse]"
  recEnemy.Description = string.format("%03d. %s", v.id, v.name)

  local bit = v.id * 11

  for _, aff in pairs(affinities) do
    local recAff = mrNew()
    recAff.appendToEntry(recEnemy)
    recAff.DontSave = true

    recAff.Address = from + 3 - bit // 8 + (bit // 32) * 8
    recAff.Type = vtBinary
    recAff.Binary.Startbit = bit % 8
    recAff.Binary.Size = 1
    recAff.Description = aff

    bit = bit + 1
  end
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>75</ID>
              <Description>"Enemy Data - Defeated"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segEnemyData+1E4")

local enemies = filterTable(tab.enemy, fNotHasTag("FLR|BLN", false))

for _, v in pairs(enemies) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Address = from + 3 - v.id // 8 + (v.id // 32) * 8
  rec.Type = vtBinary
  rec.Binary.Startbit = v.id % 8
  rec.Binary.Size = 1
  rec.Description = string.format("%03d. %s", v.id, v.name)
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>76</ID>
              <Description>"Enemy Data - Known Attack Aff. (Multi)"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segEnemyData+1E4+2C")
local affinities = { "Phys", "Gun", "Fire", "Ice", "Elec", "Wind", "Psy",
  "Nuke", "Bless", "Curse", "Almighty" }

local enemies = filterTable(tab.enemy, fNotHasTag("FLR|BLN", false))

for _, v in pairs(enemies) do
  local recEnemy = mrNew()
  recEnemy.appendToEntry(memrec)
  recEnemy.DontSave = true

  recEnemy.IsGroupHeader = true
  recEnemy.Options = "[moHideChildren, moManualExpandCollapse]"
  recEnemy.Description = string.format("%03d. %s", v.id, v.name)

  local bit = v.id * 11

  for _, aff in pairs(affinities) do
    local recAff = mrNew()
    recAff.appendToEntry(recEnemy)
    recAff.DontSave = true

    recAff.Address = from + 3 - bit // 8 + (bit // 32) * 8
    recAff.Type = vtBinary
    recAff.Binary.Startbit = bit % 8
    recAff.Binary.Size = 1
    recAff.Description = aff

    bit = bit + 1
  end
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>77</ID>
              <Description>"Enemy Data - Known Attack Aff. (Single)"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segEnemyData+1E4+2C+1E4")
local affinities = { "Phys", "Gun", "Fire", "Ice", "Elec", "Wind", "Psy",
  "Nuke", "Bless", "Curse", "Almighty" }

local enemies = filterTable(tab.enemy, fNotHasTag("FLR|BLN", false))

for _, v in pairs(enemies) do
  local recEnemy = mrNew()
  recEnemy.appendToEntry(memrec)
  recEnemy.DontSave = true

  recEnemy.IsGroupHeader = true
  recEnemy.Options = "[moHideChildren, moManualExpandCollapse]"
  recEnemy.Description = string.format("%03d. %s", v.id, v.name)

  local bit = v.id * 11

  for _, aff in pairs(affinities) do
    local recAff = mrNew()
    recAff.appendToEntry(recEnemy)
    recAff.DontSave = true

    recAff.Address = from + 3 - bit // 8 + (bit // 32) * 8
    recAff.Type = vtBinary
    recAff.Binary.Startbit = bit % 8
    recAff.Binary.Size = 1
    recAff.Description = aff

    bit = bit + 1
  end
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>78</ID>
          <Description>"Time"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>79</ID>
              <Description>"Day"</Description>
              <DropDownListLink>dlDate</DropDownListLink>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segTime+0</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>80</ID>
              <Description>"Time"</Description>
              <DropDownListLink>slTime</DropDownListLink>
              <VariableType>Byte</VariableType>
              <Address>_segTime+2</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>81</ID>
              <Description>"Next Enabled"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTime+3</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>82</ID>
              <Description>"Next Day"</Description>
              <DropDownListLink>dlDate</DropDownListLink>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segTime+4</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>83</ID>
              <Description>"Next Time"</Description>
              <DropDownListLink>slTime</DropDownListLink>
              <VariableType>Byte</VariableType>
              <Address>_segTime+6</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>84</ID>
          <Description>"Item Info"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segItemInfo")

for _, invGroup in pairs(INVENTORY) do
  local recGroup = mrNew()
  recGroup.appendToEntry(memrec)
  recGroup.DontSave = true

  recGroup.IsGroupHeader = true
  recGroup.Options = "[moHideChildren,moManualExpandCollapse]"
  recGroup.Description = invGroup.name

  local items = filterTable(invGroup.data, fNotHasTag("FLR|BLN", false))

  for _, invItem in pairs(items) do
    local rec = mrNew()
    rec.appendToEntry(recGroup)
    rec.DontSave = true

    rec.Type = vtByte
    rec.Address = from + invItem.id

    local desc = string.format("%03d. %s", invItem.id, invItem.name)
    if invItem.tag and invItem.tag ~= "" then
      desc = string.format("%s [%s]", desc, invItem.tag)
    end
    if invItem.skill and invItem.skill ~= "" and invItem.skill ~= "0" then
      desc = string.format("%s &lt;%s&gt;", desc, tab.skill[1 * invItem.skill + 1].name)
    end
    rec.Description = desc
  end

  from = from + 4096
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>85</ID>
          <Description>"Confidants"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <VariableType>Auto Assembler Script</VariableType>
          <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segConfidants")
local tmp = mrClone(mrDesc("dsCmm"), from)

for i = 0, CONF_COUNT - 1 do
  local rec = mrClone(tmp, 4 + CONF_SIZE * i)
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Description = string.format("Confidant #%02d", i + 1)
end

tmp.destroy()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
        </CheatEntry>
        <CheatEntry>
          <ID>86</ID>
          <Description>"Social Stats"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>87</ID>
              <Description>"Knowledge"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segSocialStats+0</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>88</ID>
              <Description>"Charm"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segSocialStats+2</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>89</ID>
              <Description>"Proficiency"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segSocialStats+4</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>90</ID>
              <Description>"Guts"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segSocialStats+6</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>91</ID>
              <Description>"Kindness"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segSocialStats+8</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>92</ID>
          <Description>"Names"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>93</ID>
              <Description>"Full Name (UTF8)"</Description>
              <VariableType>String</VariableType>
              <Length>56</Length>
              <Unicode>0</Unicode>
              <CodePage>0</CodePage>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>_segNames+0</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>94</ID>
              <Description>"Last Name (GAME)"</Description>
              <VariableType>String</VariableType>
              <Length>20</Length>
              <Unicode>0</Unicode>
              <CodePage>0</CodePage>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>_segNames+38</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>95</ID>
              <Description>"First Name (GAME)"</Description>
              <VariableType>String</VariableType>
              <Length>20</Length>
              <Unicode>0</Unicode>
              <CodePage>0</CodePage>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>_segNames+38+14</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>96</ID>
              <Description>"Full Name (GAME)"</Description>
              <VariableType>String</VariableType>
              <Length>40</Length>
              <Unicode>0</Unicode>
              <CodePage>0</CodePage>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>_segNames+38+14+14</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>97</ID>
              <Description>"Group Name (GAME)"</Description>
              <VariableType>String</VariableType>
              <Length>25</Length>
              <Unicode>0</Unicode>
              <CodePage>0</CodePage>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>_segNames+38+14+14+28</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>98</ID>
              <Description>"Group Name (UTF8)"</Description>
              <VariableType>String</VariableType>
              <Length>37</Length>
              <Unicode>0</Unicode>
              <CodePage>0</CodePage>
              <ZeroTerminate>1</ZeroTerminate>
              <Address>_segNames+38+14+14+28+19</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>99</ID>
          <Description>"Playtime"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>100</ID>
              <Description>"Playtime (30 * 60 * (60 * h + m))"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>4 Byte Big Endian</CustomType>
              <Address>_segPlayTime+0</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>101</ID>
          <Description>"Activity Log"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>102</ID>
              <Description>"Activity Progress"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segActivityLog")

for _, v in pairs(tab.activity) do
  if v.item ~= "0" then
    local rec = mrNew()
    rec.appendToEntry(memrec)
    rec.DontSave = true

    rec.Address = from + v.id * 4
    rec.Type = ACT_PROG_TYPE

    if ACT_PROG_TYPE == vtCustom then
      rec.CustomTypeName = "4 Byte Big Endian"
    end

    rec.Description = string.format("%03d. %s [%s]", v.id, tab.items[1 * v.item].name, v.tag)
  end
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>103</ID>
              <Description>"Activity Completion"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segActivityLog+80*4")

for _, v in pairs(tab.activity) do
  if v.item ~= "0" then
    local rec = mrNew()
    rec.appendToEntry(memrec)
    rec.DontSave = true

    rec.Address = from + v.id * 1
    rec.Type = vtByte
    rec.Description = string.format("%03d. %s [%s]", v.id, tab.items[1 * v.item].name, v.tag)
  end
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
        <CheatEntry>
          <ID>104</ID>
          <Description>"Trophies"</Description>
          <Options moHideChildren="1" moManualExpandCollapse="1" />
          <GroupHeader>1</GroupHeader>
          <CheatEntries>
            <CheatEntry>
              <ID>105</ID>
              <Description>"Fusions #"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+0</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>106</ID>
              <Description>"???"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+1</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>107</ID>
              <Description>"All-out Attacks #"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+2</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>108</ID>
              <Description>"Weaknesses Exploited #"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+3</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>109</ID>
              <Description>"Negotiations - Personas Obtained #"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+4</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>110</ID>
              <Description>"Morgana Line Flags"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end
if memrec.Count &gt; 0 then return end

local addr = getAddress("_segTrophies") + 5

for _, v in pairs(tab.morgana) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Address = string.format("%x", addr + (v.id - (v.id - 1) % 8) // 8)
  rec.Type = vtBinary
  rec.Binary.Size = 1
  rec.Binary.Startbit = (v.id - 1) % 8
  rec.Description = string.format("%03d. %s", v.id, v.line)
end

{$asm}

[DISABLE]
{$lua}

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>111</ID>
              <Description>"Futaba Line Flags"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end
if memrec.Count &gt; 0 then return end

local addr = getAddress("_segTrophies") + 5

for _, v in pairs(tab.futaba) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Address = string.format("%x", addr + (v.id - (v.id - 1) % 8) // 8)
  rec.Type = vtBinary
  rec.Binary.Size = 1
  rec.Binary.Startbit = (v.id - 1) % 8
  rec.Description = string.format("%03d. %s", v.id, v.line)
end

{$asm}

[DISABLE]
{$lua}

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>112</ID>
              <Description>"Navi Line #"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>4 Byte Big Endian</CustomType>
              <Address>_segTrophies+68</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>113</ID>
              <Description>"Confidants Maxed"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+6C</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>114</ID>
              <Description>"Requests Completed"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+6D</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>115</ID>
              <Description>"???"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+6E</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>116</ID>
              <Description>"Drink Flags"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local csvDrinks = [[id,name
00,Arginade
01,Dr. Salt NEO
02,Joylent
03,Second Maid
04,Mad Bull
05,Muscle Tea
06,Manta
07,Nastea
08,1UP
09,Earl Green
10,Starvicks
11,Udagawa Water
12,Durian-au-Lait
13,Oh! Shiruko
14,Chunky Potage
15,Ultimate Amazake
16,Udagawa Soda
17,Water of Rebirth
18,Strawberry Curry
19,Mayo Locust
20,Miso Starfish
21,Mystery Stew
22,Muscle Drink
23,Odd Morsel
24,Rancid Gravy
25,Creature
26,
27,
28,
29,
30,
31,
]]

local tblDrinks = tsvToTable(csvDrinks, nil, ",")
local from = getAddress("_segTrophies") + 111

for _, v in pairs(tblDrinks) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Type = vtBinary
  rec.Address = from
  rec.Binary.Startbit = v.id
  rec.Binary.Size = 1
  rec.Description = string.format("%02d. %s", v.id, v.name)
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>117</ID>
              <Description>"???"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+73</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>118</ID>
              <Description>"Drinks"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+74</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>119</ID>
              <Description>"Tool Flags"</Description>
              <Options moHideChildren="1" moManualExpandCollapse="1" />
              <VariableType>Auto Assembler Script</VariableType>
              <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local csvTools = [[id,name
00,Lockpick
01,Stealthanol
02,Goho-M
03,Vanish Ball
04,Smokescreen
05,Element Set
06,Element Set
07,Element Set
08,Element Set
09,Spotlight
10,Treasure Trap
11,Hypno Mist
12,Covertizer
13,Forces Set
14,Forces Set
15,Forces Set
16,Forces Set
17,Megido Bomb
18,Limelight
19,Eternal Lockpick
20,Reserve Ammo
21,
22,
23,
24,
25,
26,
27,
28,
29,
30,
31,
]]

local tblTools = tsvToTable(csvTools, nil, ",")
local from = getAddress("_segTrophies") + 117

for _, v in pairs(tblTools) do
  local rec = mrNew()
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Type = vtBinary
  rec.Address = from
  rec.Binary.Startbit = v.id
  rec.Binary.Size = 1
  rec.Description = string.format("%02d. %s", v.id, v.name)
end

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
            </CheatEntry>
            <CheatEntry>
              <ID>120</ID>
              <Description>"Tools"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+79</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>121</ID>
              <Description>"Ambushes"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+7A</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>122</ID>
              <Description>"???"</Description>
              <VariableType>Byte</VariableType>
              <Address>_segTrophies+7B</Address>
            </CheatEntry>
            <CheatEntry>
              <ID>123</ID>
              <Description>"Items Obtained #"</Description>
              <VariableType>Custom</VariableType>
              <CustomType>2 Byte Big Endian</CustomType>
              <Address>_segTrophies+7C</Address>
            </CheatEntry>
          </CheatEntries>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>124</ID>
      <Description>"Field Data"</Description>
      <Options moHideChildren="1" moManualExpandCollapse="1" />
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end

local from = getAddress("_segFieldData")
local tmp = mrClone(mrDesc("dsFieldData"), from)
local desc = { "Save", "???" }

for i, v in pairs(desc) do
  local rec = mrClone(tmp, 0x30 * (i - 1))
  rec.appendToEntry(memrec)
  rec.DontSave = true

  rec.Description = "Field Data - " .. v
end

tmp.destroy()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>125</ID>
      <Description>"Unit Lists (In Battle)"</Description>
      <Options moHideChildren="1" moManualExpandCollapse="1" />
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

local g_base = 0x400000000

local function readPtr(addr)
  return g_base + readBE4(addr)
end

local function createBtlUnitRecord(recGroup, ptrUnit)
  local recUnit = mrClone(mrDesc("dsUnit"), ptrUnit)
  recUnit.appendToEntry(recGroup)
  recUnit.DontSave = true

  local unitType = readBE2(ptrUnit + 4)
  local unitId = readBE4(ptrUnit + 8)

  local unitData = { id = unitId, name = "Unknown" }

  if unitType == 1 then
    for _, x in pairs(mrGetChildren(recUnit, mrByDesc("%[Hero%]"))) do x.destroy() end
    for _, x in pairs(mrGetChildren(recUnit, mrByDesc("%[Enemy%]"))) do x.destroy() end
    unitData = tableGet(tab.party, unitId + 1, unitData)
    recUnit.Description = string.format("%02d. %s", unitData.id, unitData.name)
    addDDLRef(recUnit[2], false, "dlParty", nil)
  elseif unitType == 2 then
    for _, x in pairs(mrGetChildren(recUnit, mrByDesc("%[Hero%]"))) do x.destroy() end
    unitData = tableGet(tab.enemy, unitId + 1, unitData)
    recUnit.Description = string.format("%03d. %s", unitData.id, unitData.name)
    addDDLRef(recUnit[2], false, "dlEnemy", nil)
  else
    recUnit.Description = "Unit " .. unitId
    addDDLRef(recUnit[2], true, nil, nil)
  end
end

local function createBtlUnitList(recGroup, ptrList)
  local recSize = mrNew()
  recSize.appendToEntry(recGroup)
  recSize.DontSave = true

  recSize.Address = ptrList + 8
  recSize.Type = vtCustom
  recSize.CustomTypeName = "4 Byte Big Endian"
  recSize.Description = "Size"

  local ptrUnitWrapper = readPtr(ptrList)

  for e = 0, 15 do
    if ptrUnitWrapper == g_base then break end
    local ptrUnit = readPtr(readPtr(readPtr(ptrUnitWrapper + 8 + 12) + 24) + 4)
    createBtlUnitRecord(recGroup, ptrUnit)
    ptrUnitWrapper = readPtr(ptrUnitWrapper)
  end
end

local function createBtlUnitLists()
  local names = { "Party", "Enemy", "All" }
  local ptrLists = readPtr(readPtr(readPtr(g_base + 0x1183C90) + 84) + 52)

  for i = 0, 2 do
    local recType = mrNew()
    recType.appendToEntry(memrec)
    recType.DontSave = true

    recType.IsGroupHeader = true
    recType.Options = "[moHideChildren,moManualExpandCollapse]"
    recType.Description = names[i + 1]

    createBtlUnitList(recType, ptrLists + 4 + 132 + 16 * i)
  end
end

createBtlUnitLists()

{$asm}

[DISABLE]
{$lua}

if syntaxcheck then return end
while memrec.Count &gt; 0 do memrec[0].destroy() end

{$asm}

</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols />
  <LuaScript>--------------------------------------
-- Persona 5 Cheat Table Lua Script --
--------------------------------------

function updateSymbol(name, address, ...)
  unregisterSymbol(name)
  registerSymbol(name, address, ... or false)
end

----------------------
-- Big Endian Types --
----------------------

function readAll(filePath)
  local fileStream = io.open(filePath, "rb")
  local content = fileStream:read("*all")
  fileStream:close()
  return content
end

function tryGetCustomType(customTypeName, customTypeFilePath)
  local customType = getCustomType(customTypeName)
  if customType == nil then
    local customTypeScript = readAll(customTypeFilePath)
    customType = registerCustomTypeAutoAssembler(customTypeScript)
  end
  return customType
end

be4 = tryGetCustomType("4 Byte Big Endian", "types/be4.cea")
be2 = tryGetCustomType("2 Byte Big Endian", "types/be2.cea")
bef = tryGetCustomType("Float Big Endian", "types/befloat.cea")

function readBE2(addr) return be2.byteTableToValue(readBytes(addr, 2, true)) end
function readBE4(addr) return be4.byteTableToValue(readBytes(addr, 4, true)) end
function readBEF(addr) return bef.byteTableToValue(readBytes(addr, 4, true)) end

function writeBE2(addr, value) writeBytes(addr, be2.valueToByteTable(value)) end
function writeBE4(addr, value) writeBytes(addr, be4.valueToByteTable(value)) end
function writeBEF(addr, value) writeBytes(addr, bef.valueToByteTable(value)) end

-------------------------
-- Auxillary Functions --
-------------------------

--- iterates over tables in a given order
function spairs(t, order)
  -- collect the keys
  local keys = {}
  for k in pairs(t) do keys[#keys + 1] = k end

  -- if order function given, sort by it by passing the table and keys a, b,
  -- otherwise just sort the keys
  if order then
    table.sort(keys, function(a, b) return order(t, a, b) end)
  else
    table.sort(keys)
  end

  -- return the iterator function
  local i = 0
  return function()
    i = i + 1
    if keys[i] then
      return keys[i], t[keys[i]]
    end
  end
end

--- splits a string using a delimiter
function splitString(s, sep)
  local out, n = {}, 1
  for w in s:gmatch("([^"..sep.."]*)") do
    out[n] = out[n] or w
    if w == "" then n = n + 1 end
  end
  return out
end

--- filters a table using a filter iterator
function filterTable(t, filter, ...)
  local out, keepKeys = {}, ...

  for k, v in pairs(t) do
    if not filter or filter(v, k, t) then
      if keepKeys then
        out[k] = v
      else
        table.insert(out, v)
      end
    end
  end
  return out
end

------------------
-- Record Manip --
------------------

--- returns a memory record by description
function mrDesc(desc)
  return getAddressList().getMemoryRecordByDescription(desc)
end

--- returns a memory record by id
function mrID(id)
  return getAddressList().getMemoryRecordByID(id)
end

--- creates a new memory record
function mrNew()
  return getAddressList().createMemoryRecord()
end

--- returns a list of children records of a given memory record using an
--- optional filter function
function mrGetChildren(mr, ...)
  local c, filter = {}, ...
  if filter == nil or filter(mr) then
    table.insert(c, mr)
  end
  for i = 0, mr.Count - 1 do
    for k, v in pairs(mrGetChildren(mr.Child[i], filter)) do table.insert(c, v) end
  end
  return c
end

--- clones a memory record using an optional offset
function mrClone(mr, ...)
  if mr == nil then return end

  local r, offset, root = getAddressList().createMemoryRecord(), ...
  local addr = mr.Address ~= '' and tonumber(mr.Address, 16) or 0
  offset = offset or 0

  if not root then
    r.Description = mr.Description .. " - Copy"
    root = true
  else
    r.Description = mr.Description
  end

  r.Address = string.format("%x", addr + offset)
  r.Type = mr.Type
  r.Binary.Size = mr.Binary.Size
  r.Binary.Startbit = mr.Binary.Startbit
  r.CustomTypeName = mr.CustomTypeName
  r.IsGroupHeader = mr.IsGroupHeader
  r.Options = mr.Options
  r.Script = mr.Script

  r.ShowAsHex = mr.ShowAsHex
  r.Aob.Size = mr.Aob.Size

  r.DropDownLinked = mr.DropDownLinked
  r.DropDownLinkedMemrec = mr.DropDownLinkedMemrec

  for i = 0, mr.Count - 1 do
    mrClone(mr[i], offset, root).appendToEntry(r)
  end

  return r
end

-------------
-- Filters --
-------------

function oByLevel(t, a, b)
  return 0 + t[a]['lv'] &gt; 0 + t[b]['lv']
end

function oByArcanaLevel(t, a, b)
  return (0 + 0 + t[a]['ar'] &lt; 0 + t[b]['ar'])
    or (0 + t[a]['ar'] == 0 + t[b]['ar']
      and 0 + t[a]['lv'] &gt; 0 + t[b]['lv'])
end

function multiMatch(str, mm, ...)
  local result, all = true, ... or false

  for _, v in pairs(mm) do
    result = (result or not all) and str and str:match(v) ~= nil
    if not all and result then
      break
    end
  end

  return result
end

function mrByParentDesc(desc)
  return function(x)
      return x.Parent and x.Parent.Description:match(desc) ~= nil
    end
end

function mrByDesc(desc)
  return function(x)
      return x.Description:match(desc) ~= nil
    end
end

function fHasTag(tag, ...)
  local matchAll = ...
  return function(v, k, t)
    return multiMatch(v.tag, splitString(tag, '|'), matchAll)
  end
end

function fNotHasTag(tag, ...)
  local matchAll = ...
  return function(v, k, t)
    return not multiMatch(v.tag, splitString(tag, '|'), matchAll)
  end
end

function fById(id)
  return function(v, k, t)
    return v.id == id
  end
end

function fByArcana(id)
  return function(v, k, t)
    return v.arcana == id
  end
end

---------------------
-- Drop-Down Lists --
---------------------

--- adds (or removes) a drop-down list to (or from) a memory record
function setDDL(mr, clear, list, ...)
  local listOptions = ... or {false, false, false}

  mr.DropDownList.Text         = clear and '' or list
  mr.DropDownReadOnly          = clear and false or listOptions[1]
  mr.DropDownDescriptionOnly   = clear and false or listOptions[2]
  mr.DisplayAsDropDownListItem = clear and false or listOptions[3]
end

--- adds (or removes) a reference to a drop-down list record
function addDDLRef(header, clear, list, ...)
  local filter = ...
  local mrs = mrGetChildren(header, filter)
  for _, v in pairs(mrs) do
    v.DropDownLinked = not clear
    v.DropDownLinkedMemrec = clear and '' or list
  end
end

--- row formatter, returns a string describing a table row for a drop-down list
function fmtIdNameTag(v)
  if v.tag and v.tag ~= "" then
    return string.format("%d:%s [%s]", v.id, v.name, v.tag)
  end
  return string.format("%d:%s", v.id, v.name)
end

--- creates a drop-down list from a table using a given row formatter
function ddlFromTable(t, rf)
  local ddl = ""

  for _, v in pairs(t) do
    local r = rf(v)
    ddl = string.format("%s\r\n%s", ddl, r)
  end

  return string.sub(ddl, 3)
end

----------
-- Data --
----------

function tsvToTable(tsv, ...)
  local out, header, delim = {}, ...

  if delim == nil then delim = '\t' end

  for i in string.gmatch(tsv, "(.-)\r?\n") do
    local fields = splitString(i, delim)
    if header == nil then
      header = fields
    else
      local entry = {}
      for j, v in pairs(header) do
        entry[v] = fields[j]
      end
      table.insert(out, entry)
    end
  end
  return out
end

function loadData(data)
  local tab = {}
  for tableName, filePath in pairs(data) do
    tab[tableName] = tsvToTable(readAll(filePath))
  end
  return tab
end

function createDateTable()
  local t, date = {}, os.time({ year = 2016, month = 04, day = 01 })
  for d = 0, 365 do
    table.insert(t, { tag = nil, id = d, name = os.date("%m/%d", date)})
    date = date + 24 * 60 * 60
  end
  return t
end

function createDynamicLists(listData)
  local listRec = mrDesc("Dynamic Lists")
  while listRec.Count &gt; 0 do listRec[0].destroy() end

  for _, v in pairs(listData) do
    local rec = createDynamicList(v.name, v.data, nil, fmtIdNameTag)
    rec.appendToEntry(listRec)
  end
end

function createDynamicList(name, data, filter, format)
  local rec = mrNew()
  rec.DontSave = true

  rec.Description = name
  setDDL(rec, false, ddlFromTable(filterTable(data, filter), format), {false, false, true})
  return rec
end

function createItemTable(inv)
  local itemPrefix = { "M", "P", "A", "E", "K", "T", "S", "O", "R" }
  local items = {}
  for _, invGroup in pairs(inv) do
    for _, invItem in pairs(invGroup.data) do
      local itemEntry = {}
      itemEntry.id = invGroup.cat * 0x1000 + invItem.id
      itemEntry.name = string.format("%s | %s", itemPrefix[invGroup.cat + 1], invItem.name)
      itemEntry.tag = invItem.tag
      items[itemEntry.id] = itemEntry
    end
  end
  return items
end

-----------
-- Misc. --
-----------

frmCompReset = true
frmExpCalcReset = true
frmNamesReset = true

function toggleCompactMode()
  local state = not (compactMenuItem.Caption == 'Compact View')
  compactMenuItem.Caption = state and 'Compact View' or 'Full View'
  getMainForm().Splitter1.Visible = state
  getMainForm().Panel4.Visible = state
  getMainForm().Panel5.Visible = state
end

function addCompactMenu()
  if compactMenuExists then return end
  local mainFormMenu = getMainForm().Menu.Items
  compactMenuItem = createMenuItem(mainFormMenu)
  mainFormMenu.add(compactMenuItem)

  compactMenuItem.Caption = 'Compact View'
  compactMenuItem.OnClick = toggleCompactMode
  compactMenuExists = true
end

addCompactMenu()

function clearConsole()
  GetLuaEngine().MenuItem5.doClick()
end

function tableGet(tbl, idx, default)
  local ret = tbl[idx]
  if not ret then return default end
  return ret
end

</LuaScript>
</CheatTable>